> 2020 카카오 인턴십
> related topics : BFS, 다익스트라, DP

이 문제는... **3차원 DP**를 이용한 다익스트라 문제이다... 2차원으로 풀었었는데 잘못된 접근이었다.

왜냐하면 **4방향으로 각각 진입할 경우**를 고려해줘야하기 때문에 기존 `n x n` 테이블에다가, 방향을 추가하여

`n x n x 4` 테이블을 만들어야함.

# 접근 : 3차원 DP + 다익스트라

1. `n x n x 4` DP 테이블을 생성하고,

2. 처음에는 방향을 `-1` 로 설정해준다. 이 부분은 비용을 계산하는 함수에서 잘 처리해주면 됨.

3. 방향이 맞으면 직진인 것이고 다르면 코너링인 것임. 이를 이용해서 다익스트라 BFS를 돌리면 된다.

2번에서 주의할 점... 파이썬에서는 `배열[-1]`을 맨 끝의 값으로 잘 처리하지만 자바스크립트는 `NaN`을 반환한다... 이 기본적인 것을 놓쳐서 자바스크립트 풀이에 좀 애를 먹었다. 따라서 비용을 계산하는 부분에서 잘 처리를 해주거나, dp테이블에서 값에 접근할 때 이 점을 고려해주거나 해야한다...

#### python

```python
from collections import deque

def solution(board):
    INF = int(1e9)
    n = len(board)

    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    def is_road(x, y):
        return board[x][y] == 0

    def validate_range(x, y):
        return 0 <= x < n and 0 <= y < n

    # 파이썬에서는 괜찮지만 다른 언어에서는 버그가 생길 수 있음. (이 부분 처리는 자바스크립트 풀이에서 한 것처럼 바꾸는 것이 좋다.)
    # 근데 주의사항이니까 안바꾸고 그냥 두겠음.
    def add_cost(cost, direction, next_direction):
        if direction == -1 or direction == next_direction:
            return cost + 100
        return cost + 600

    # n x n x 4(방향) 3차원 dp
    costs = [[[INF] * 4 for _ in range(n)] for _ in range(n)]

    # x, y, 방향(인덱스)
    q = deque([[0, 0, -1]])

    # (0, 0)은 비용이 0
    costs[0][0] = [0, 0, 0, 0]

    while q:
        x, y, direction = q.popleft()
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if not validate_range(nx, ny) or not is_road(nx, ny):
                continue

            next_cost = add_cost(costs[x][y][direction], direction, i)

            if costs[nx][ny][i] > next_cost:
                costs[nx][ny][i] = next_cost
                q.append([nx, ny, i])

    return min(costs[n - 1][n - 1])
"""
정확성  테스트
테스트 1 〉	통과 (0.09ms, 10MB)
테스트 2 〉	통과 (0.05ms, 10.3MB)
테스트 3 〉	통과 (0.05ms, 10.1MB)
테스트 4 〉	통과 (0.08ms, 10.3MB)
테스트 5 〉	통과 (0.15ms, 10.1MB)
테스트 6 〉	통과 (1.09ms, 10.1MB)
테스트 7 〉	통과 (1.20ms, 10MB)
테스트 8 〉	통과 (1.07ms, 10.3MB)
테스트 9 〉	통과 (2.04ms, 10.3MB)
테스트 10 〉	통과 (3.43ms, 10.1MB)
테스트 11 〉	통과 (10.70ms, 10.2MB)
테스트 12 〉	통과 (10.19ms, 10.2MB)
테스트 13 〉	통과 (0.86ms, 10.2MB)
테스트 14 〉	통과 (0.42ms, 10.1MB)
테스트 15 〉	통과 (1.49ms, 10.1MB)
테스트 16 〉	통과 (4.87ms, 10.2MB)
테스트 17 〉	통과 (3.27ms, 10.3MB)
테스트 18 〉	통과 (7.56ms, 10.4MB)
테스트 19 〉	통과 (4.31ms, 10.1MB)
테스트 20 〉	통과 (5.12ms, 10.3MB)
테스트 21 〉	통과 (3.37ms, 10.3MB)
테스트 22 〉	통과 (0.32ms, 10.3MB)
테스트 23 〉	통과 (0.15ms, 10.1MB)
테스트 24 〉	통과 (0.17ms, 10MB)
테스트 25 〉	통과 (0.15ms, 10.4MB)
"""
```

#### js

```js
function solution(board) {
  const n = board.length
  const dx = [0, 1, 0, -1]
  const dy = [1, 0, -1, 0]

  const addCost = (cost, direction, nextDirection) => {
    // 처음 방향이 -1이라는 것은 (0, 0)에서 출발이라는 것이므로 그냥 직진처리 (이 경우 cost는 NaN이라는 것을 주의해야한다.)
    if (direction === -1) {
      return 100
    }
    if (direction === nextDirection) {
      return cost + 100
    }
    return cost + 600
  }

  const isRoad = (x, y) => {
    return board[x][y] === 0
  }

  const validateRange = (nx, ny) => {
    return 0 <= nx && nx < n && 0 <= ny && ny < n
  }

  // 3차원 n x n x 4 테이블 생성
  const costs = Array.from({ length: n }, () =>
    Array.from({ length: n }, () => new Array(4).fill(Infinity)),
  )

  const q = [[0, 0, -1]] // x, y, 방향
  costs[0][0] = [0, 0, 0, 0] // (0, 0)의 비용은 모두 0

  while (q.length > 0) {
    const [x, y, direction] = q.shift()
    const cost = costs[x][y][direction] // direction은 처음에 -1이라는 것을 주의
    for (let i = 0; i < 4; i += 1) {
      const nx = x + dx[i]
      const ny = y + dy[i]

      if (!validateRange(nx, ny) || !isRoad(nx, ny)) {
        continue
      }

      const nextCost = addCost(cost, direction, i)
      if (costs[nx][ny][i] > nextCost) {
        costs[nx][ny][i] = nextCost
        q.push([nx, ny, i])
      }
    }
  }

  return Math.min(...costs[n - 1][n - 1])
}
// 정확성  테스트
// 테스트 1 〉	통과 (0.39ms, 33.5MB)
// 테스트 2 〉	통과 (0.32ms, 33.4MB)
// 테스트 3 〉	통과 (0.31ms, 33.5MB)
// 테스트 4 〉	통과 (0.45ms, 33.4MB)
// 테스트 5 〉	통과 (0.57ms, 33.5MB)
// 테스트 6 〉	통과 (1.08ms, 33.6MB)
// 테스트 7 〉	통과 (1.03ms, 33.6MB)
// 테스트 8 〉	통과 (0.89ms, 33.6MB)
// 테스트 9 〉	통과 (1.51ms, 33.6MB)
// 테스트 10 〉	통과 (1.31ms, 33.8MB)
// 테스트 11 〉	통과 (11.10ms, 37.1MB)
// 테스트 12 〉	통과 (10.15ms, 37.1MB)
// 테스트 13 〉	통과 (0.62ms, 33.5MB)
// 테스트 14 〉	통과 (0.85ms, 33.5MB)
// 테스트 15 〉	통과 (1.15ms, 33.7MB)
// 테스트 16 〉	통과 (1.95ms, 35.7MB)
// 테스트 17 〉	통과 (3.87ms, 35.8MB)
// 테스트 18 〉	통과 (3.21ms, 36.2MB)
// 테스트 19 〉	통과 (2.69ms, 35.9MB)
// 테스트 20 〉	통과 (2.63ms, 35.9MB)
// 테스트 21 〉	통과 (2.44ms, 33.9MB)
// 테스트 22 〉	통과 (0.44ms, 33.4MB)
// 테스트 23 〉	통과 (0.72ms, 33.5MB)
// 테스트 24 〉	통과 (0.65ms, 33.5MB)
// 테스트 25 〉	통과 (0.62ms, 33.5MB)
```
