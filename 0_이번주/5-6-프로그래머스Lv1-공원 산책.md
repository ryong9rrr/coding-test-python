---
layout: post
title: "프로그래머스 Lv1) 공원 산책"
tags: [2차원 배열, 구현]
comments: true
categories:
---

> 기본적인 구현(시뮬레이션) 문제

---

> [프로그래머스 Lv1) 공원 산책](https://school.programmers.co.kr/learn/courses/30/lessons/172928)

시뮬레이션 문제인데, 방향 처리하는 부분이 약간 까다로울 수 있다.

# 접근 : 구현(시뮬레이션)

행렬의 전체 크기가 작으므로,

1. 로봇이 움직일 수 있는지 먼저 확인한 뒤,
2. 로봇을 이동시킨다.

## 파이썬

```python
def solution(park, routes):
    n = len(park)
    m = len(park[0])

    def validate_range(x, y):
        return 0 <= x < n and 0 <= y < m

    def get_next_position(current_x, current_y, op, step):
        if op == "N":
            return [current_x - step, current_y]
        if op == "S":
            return [current_x + step, current_y]
        if op == "W":
            return [current_x, current_y - step]
        return [current_x, current_y + step]

    def can_move(current_x, current_y, op, nx, ny):
        if not validate_range(nx, ny):
            return False

        if op == "N":
            for i in range(nx, current_x + 1):
                if park[i][current_y] == "X":
                    return False
        if op == "S":
            for i in range(current_x, nx + 1):
                if park[i][current_y] == "X":
                    return False
        if op == "W":
            for j in range(ny, current_y + 1):
                if park[current_x][j] == "X":
                    return False
        if op == "E":
            for j in range(current_y, ny + 1):
                if park[current_x][j] == "X":
                    return False
        return True


    current_x = current_y = 0
    for i in range(n):
        for j in range(m):
            if park[i][j] == "S":
                current_x = i
                current_y = j
                break

    for route in routes:
        op, s = route.split(" ")
        step = int(s)
        nx, ny = get_next_position(current_x, current_y, op, step)
        if can_move(current_x, current_y, op, nx, ny):
            current_x, current_y = nx, ny

    return [current_x, current_y]
"""
정확성  테스트
테스트 1 〉	통과 (0.02ms, 10.5MB)
테스트 2 〉	통과 (0.04ms, 10.4MB)
테스트 3 〉	통과 (0.05ms, 10.5MB)
테스트 4 〉	통과 (0.10ms, 10.3MB)
테스트 5 〉	통과 (0.13ms, 10.4MB)
테스트 6 〉	통과 (0.25ms, 10.4MB)
테스트 7 〉	통과 (0.25ms, 10.5MB)
테스트 8 〉	통과 (0.25ms, 10.4MB)
테스트 9 〉	통과 (0.43ms, 10.4MB)
테스트 10 〉	통과 (0.25ms, 10.5MB)
테스트 11 〉	통과 (0.26ms, 10.3MB)
테스트 12 〉	통과 (0.37ms, 10.4MB)
테스트 13 〉	통과 (0.24ms, 10.4MB)
테스트 14 〉	통과 (0.26ms, 10.4MB)
테스트 15 〉	통과 (0.48ms, 10.4MB)
테스트 16 〉	통과 (0.06ms, 10.4MB)
테스트 17 〉	통과 (0.14ms, 10.5MB)
테스트 18 〉	통과 (0.04ms, 10.3MB)
테스트 19 〉	통과 (0.24ms, 10.4MB)
테스트 20 〉	통과 (0.07ms, 10.5MB)
"""
```

## js

```js
function solution(park, routes) {
  const n = park.length
  const m = park[0].length

  const validateRange = (x, y) => {
    return 0 <= x && x < n && 0 <= y && y < m
  }

  const isWall = (x, y) => {
    return park[x][y] === "X"
  }

  const canMoveForN = (x, y, nx, ny) => {
    for (let i = nx; i < x + 1; i += 1) {
      if (isWall(i, ny)) {
        return false
      }
    }
    return true
  }

  const canMoveForS = (x, y, nx, ny) => {
    for (let i = x; i < nx + 1; i += 1) {
      if (isWall(i, ny)) {
        return false
      }
    }
    return true
  }

  const canMoveForW = (x, y, nx, ny) => {
    for (let j = ny; j < y + 1; j += 1) {
      if (isWall(x, j)) {
        return false
      }
    }
    return true
  }

  const canMoveForE = (x, y, nx, ny) => {
    for (let j = y; j < ny + 1; j += 1) {
      if (isWall(x, j)) {
        return false
      }
    }
    return true
  }

  const initPosition = () => {
    for (let i = 0; i < n; i += 1) {
      for (let j = 0; j < m; j += 1) {
        if (park[i][j] === "S") {
          return [i, j]
        }
      }
    }
  }

  const getNextPosition = (x, y, op, step) => {
    const nextStep = {
      N: [x - step, y],
      S: [x + step, y],
      W: [x, y - step],
      E: [x, y + step],
    }
    return nextStep[op]
  }

  const canMove = (x, y, op, nx, ny) => {
    const canMoveFor = {
      N: canMoveForN,
      S: canMoveForS,
      W: canMoveForW,
      E: canMoveForE,
    }
    return validateRange(nx, ny) ? canMoveFor[op](x, y, nx, ny) : false
  }

  let [curX, curY] = initPosition()
  for (const route of routes) {
    const [op, s] = route.split(" ")
    const step = Number(s)
    const [nx, ny] = getNextPosition(curX, curY, op, step)
    if (canMove(curX, curY, op, nx, ny)) {
      curX = nx
      curY = ny
    }
  }

  return [curX, curY]
}
// 정확성  테스트
// 테스트 1 〉	통과 (0.25ms, 33.6MB)
// 테스트 2 〉	통과 (0.61ms, 33.4MB)
// 테스트 3 〉	통과 (0.95ms, 33.5MB)
// 테스트 4 〉	통과 (0.74ms, 33.5MB)
// 테스트 5 〉	통과 (0.68ms, 33.5MB)
// 테스트 6 〉	통과 (0.75ms, 33.7MB)
// 테스트 7 〉	통과 (0.74ms, 33.5MB)
// 테스트 8 〉	통과 (0.72ms, 33.5MB)
// 테스트 9 〉	통과 (1.17ms, 33.6MB)
// 테스트 10 〉	통과 (0.70ms, 33.5MB)
// 테스트 11 〉	통과 (0.71ms, 33.6MB)
// 테스트 12 〉	통과 (0.73ms, 33.5MB)
// 테스트 13 〉	통과 (0.80ms, 33.5MB)
// 테스트 14 〉	통과 (0.80ms, 33.6MB)
// 테스트 15 〉	통과 (0.72ms, 33.6MB)
// 테스트 16 〉	통과 (0.51ms, 33.6MB)
// 테스트 17 〉	통과 (0.58ms, 33.6MB)
// 테스트 18 〉	통과 (0.47ms, 33.4MB)
// 테스트 19 〉	통과 (0.73ms, 33.5MB)
// 테스트 20 〉	통과 (0.51ms, 33.4MB)
```
