> 2020 카카오 인턴십
> related topics :

# 접근 1 :

- 시간복잡도 : O()
- 공간복잡도 : O()

#### python

```python

```

#### js

```js

```

---

```python
from collections import deque

def solution(board):
    n = len(board)
    m = len(board[0])

    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    def is_road(x, y):
        return board[x][y] == 0

    def validate_range(x, y):
        return 0 <= x < n and 0 <= y < m

    def is_corner(px, py, nx, ny):
        return px != nx and py != ny

    min_cost = int(1e9)
    def dfs(px, py, x, y, visited, cost):
        nonlocal min_cost

        if x == n - 1 and y == m - 1:
            min_cost = min(min_cost, cost)
            return

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if validate_range(nx, ny) and is_road(nx, ny) and not visited[nx][ny]:
                visited[nx][ny] = True

                if is_corner(px, py, nx, ny):
                    cost += 600
                else:
                    cost += 100

                if min_cost > cost:
                    dfs(x, y, nx, ny, visited, cost)

                visited[nx][ny] = False # 백트래킹


    visited = [[False] * m for _ in range(n)]
    dfs(0, 0, 0, 0, visited, 0)

    return min_cost
```

```python
from collections import deque

def solution(board):
    INF = int(1e9)
    n = len(board)
    m = len(board[0])

    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    def is_road(x, y):
        return board[x][y] == 0

    def validate_range(x, y):
        return 0 <= x < n and 0 <= y < m

    def is_corner(px, py, x, y, nx, ny):
        return not (px == x == nx or py == y == ny)

    q = deque()
    costs = [[INF] * m for _ in range(n)]

    q.append([0, 0, 0, 0])
    costs[0][0] = 0
    while q:
        px, py, x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if not validate_range(nx, ny) or not is_road(nx, ny):
                continue

            cost = costs[x][y]
            if is_corner(px, py, x, y, nx, ny):
                cost += 600
            else:
                cost += 100

            if costs[nx][ny] > cost:
                costs[nx][ny] = cost
                q.append([x, y, nx, ny])

    return costs[n - 1][m - 1]
```
